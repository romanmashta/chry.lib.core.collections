<CollectionsResources/>

@using Cherry.Lib.Core.Disco.ContentViewer
@using Serilog
@using Cherry.Lib.Core.App.Discovery
@using Cherry.Lib.Core.Disco.Navigation
@inherits ResourceViewBase<IObjectCollection>

@inject INavigator Navigator
@inject ILogger Logger;

<div class="Collection-Container">
    <Paper Style="width: 100%; overflow-x: auto;">
        <Table>
            <TableHead>
                <TableRow>
                    @foreach (var accessor in Resource.Accesors)
                    {
                        <TableCell>
                            @CreateSortableColumn(accessor)
                        </TableCell>
                    }
                </TableRow>
            </TableHead>
            <TableBody>
                @if (Fetching)
                {
                    <TableRow>
                        <TableCell colspan="@(Resource.Accesors.Count())" Align="Align.Center">
                            <CircularProgress/>
                        </TableCell>
                    </TableRow>
                }
                else
                {
                    @foreach (var row in Items)
                    {
                        <tr class="TableRow-Root TableRow-Body TableRow-Hover" @onclick="e=> RowClicked(row.GetRef())">
                            @foreach (var accessor in Resource.Accesors)
                            {
                                <td class=@($"TableCell-Root TableCell-Body")>@accessor.Getter(row)</td>
                            }
                        </tr>
                    }
                }
            </TableBody>
        </Table>
        <div class="Collection-Actions">
            <Fab
                Color="@Color.Primary"
                aria-label="add">
                <AddIcon/>
            </Fab>
        </div>
    </Paper>
</div>

@code
{
    private bool Fetching = false;

    private IEnumerable<object> Items = new List<object>();


    private string SortMessage => "sort " + (Resource.Direction == SortDirection.Desc ? "descending" : "ascending");

    protected override void OnInitialized()
    {
        base.OnInitialized();
        FetchItems();
    }

    private RenderFragment CreateSortableColumn(Accessor accessor)
    {
        return @<TableSortLabel
                    Active="@(Resource.SortedBy == accessor)"
                    Direction="@(Resource.Direction == SortDirection.Asc ? Sort.Ascending : Sort.Descending)"
                    OnClick="@CreateOnSortClick(accessor)">
                   @accessor.Title
                   @if (Resource.SortedBy == accessor)
                   {
                       <span class="object-sort-visually-hidden">
                           @SortMessage
                       </span>
                   }
               </TableSortLabel>;
    }

    private async Task FetchItems()
    {
        Fetching = true;
        StateHasChanged();

        Items = await Resource.FetchItems();

        Fetching = false;
        StateHasChanged();
    }

    private EventCallback<EventArgs> CreateOnSortClick(Accessor accessor)
    {
        return EventCallback.Factory.Create<System.EventArgs>(this, (_) => { HandleSortClick(accessor); });
    }


    private void HandleSortClick(Accessor accessor)
    {
        Resource.SortedBy = accessor;
        Resource.Direction = Resource.Direction == SortDirection.Asc ? SortDirection.Desc : SortDirection.Asc;

        FetchItems();
    }
    
    private void RowClicked(string objectRef)
    {
        Logger.Information("Row clicked for object {@ref}", objectRef);
        Navigator.NavigateTo(objectRef, true, Resource);
    }    
}